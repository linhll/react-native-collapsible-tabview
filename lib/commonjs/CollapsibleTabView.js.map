{"version":3,"sources":["CollapsibleTabView.tsx"],"names":["CollapsibleTabView","animatedValue","Animated","Value","navigationState","index","routes","renderHeader","containerHeight","collapsedHeight","tabBarHeight","appBarHeight","appBar","tabBarProps","headerContainerStyle","preventTabPressOnGliding","disableSnap","headerBackground","renderTabBar","customRenderTabBar","snapThreshold","snapTimeout","routeKeyProp","tabViewProps","scrollY","React","useRef","listRefArr","listOffset","isGliding","prevOffset","isUserInteracting","lastInteractionTime","canSnap","setCanSnap","useState","activateSnapDebounced","lastInteractedAgo","Date","now","current","callback","trailing","leading","translateY","interpolate","inputRange","Math","max","outputRange","extrapolate","useLayoutEffect","currY","addListener","value","curRoute","removeAllListeners","syncScrollOffsets","useCallback","curRouteKey","offset","newOffset","calculateNewOffset","forEach","item","isCurrentRoute","key","itemOffset","ref","animated","min","maybeSnap","onMomentumScrollBegin","onMomentumScrollEnd","onScrollBeginDrag","onScrollEndDrag","onLayout","currentRef","find","r","buildGetRef","routeKey","found","e","push","props","zIndex","position","width","height","transform","styles","headerContainer","top","event","preventDefault","onTabPress","onTouchStart","onTouchEnd","container","activeRouteKey","StyleSheet","create","flex","overflow","headerHeight"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AASA;;AACA;;AACA;;;;;;;;;;AAqGA;AACA;AACA;AACA;AACA,MAAMA,kBAAkB,GAAG,CAGzB;AACAC,EAAAA,aAAa,GAAG,IAAIC,sBAASC,KAAb,CAAmB,CAAnB,CADhB;AAEAC,EAAAA,eAAe,EAAE;AAAEC,IAAAA,KAAF;AAASC,IAAAA;AAAT,GAFjB;AAGAC,EAAAA,YAAY,GAAG,MAAM,IAHrB;AAIAC,EAAAA,eAAe,GAAG,EAJlB;AAKAC,EAAAA,eAAe,GAAG,CALlB;AAMAC,EAAAA,YAAY,GAAG,EANf;AAOAC,EAAAA,YAAY,GAAG,CAPf;AAQAC,EAAAA,MARA;AASAC,EAAAA,WATA;AAUAC,EAAAA,oBAVA;AAWAC,EAAAA,wBAAwB,GAAG,IAX3B;AAYAC,EAAAA,WAAW,GAAG,KAZd;AAaAC,EAAAA,gBAbA;AAcAC,EAAAA,YAAY,EAAEC,kBAdd;AAeAC,EAAAA,aAAa,GAAG,GAfhB;AAgBAC,EAAAA,WAAW,GAAG,GAhBd;AAiBAC,EAAAA,YAAY,GAAG,KAjBf;AAkBA,KAAGC;AAlBH,CAHyB,KAsBmC;AAC5D,QAAMC,OAAO,GAAGC,eAAMC,MAAN,CAAazB,aAAb,CAAhB;;AACA,QAAM0B,UAAU,GAAGF,eAAMC,MAAN,CAAqD,EAArD,CAAnB;;AACA,QAAME,UAAU,GAAGH,eAAMC,MAAN,CAAwC,EAAxC,CAAnB;;AACA,QAAMG,SAAS,GAAGJ,eAAMC,MAAN,CAAa,KAAb,CAAlB;;AACA,QAAMI,UAAU,GAAGL,eAAMC,MAAN,CAAa,CAAb,CAAnB;AACA;;;AACA,QAAMK,iBAAiB,GAAGN,eAAMC,MAAN,CAAa,KAAb,CAA1B;;AACA,QAAMM,mBAAmB,GAAGP,eAAMC,MAAN,CAAa,CAAb,CAA5B;;AAEA,QAAM,CAACO,OAAD,EAAUC,UAAV,IAAwBT,eAAMU,QAAN,CAAe,KAAf,CAA9B;;AAEA,QAAMC,qBAAqB,GAAG,uCAC5B,MAAM;AACJ,UAAMC,iBAAiB,GAAGC,IAAI,CAACC,GAAL,KAAaP,mBAAmB,CAACQ,OAA3D,CADI,CAEJ;;AACA,QAAI,CAACT,iBAAiB,CAACS,OAAnB,IAA8BH,iBAAiB,GAAGhB,WAAtD,EAAmE;AACjEa,MAAAA,UAAU,CAAC,IAAD,CAAV;AACD,KAFD,MAEO;AACL;AACAE,MAAAA,qBAAqB,CAACK,QAAtB;AACD;AACF,GAV2B,EAW5B,EAX4B,EAWxB;AACJ;AAAEC,IAAAA,QAAQ,EAAE,IAAZ;AAAkBC,IAAAA,OAAO,EAAE;AAA3B,GAZ4B,CAA9B;AAeA,QAAMC,UAAU,GAAG,mBACjBpB,OAAO,CAACgB,OAAR,CAAgBK,WAAhB,CAA4B;AAC1BC,IAAAA,UAAU,EAAE,CAAC,CAAD,EAAIC,IAAI,CAACC,GAAL,CAASvC,eAAT,EAA0BC,YAA1B,CAAJ,CADc;AACgC;AAC1DuC,IAAAA,WAAW,EAAE,CAAC,CAAD,EAAI,CAACxC,eAAL,CAFa;AAG1ByC,IAAAA,WAAW,EAAE;AAHa,GAA5B,CADiB,EAMjBV,OANF;;AAQAf,iBAAM0B,eAAN,CAAsB,MAAM;AAC1B,UAAMC,KAAK,GAAG5B,OAAO,CAACgB,OAAtB;AACAY,IAAAA,KAAK,CAACC,WAAN,CAAkB,CAAC;AAAEC,MAAAA;AAAF,KAAD,KAAe;AAC/B,YAAMC,QAAQ,GAAGjD,MAAM,CAACD,KAAD,CAAN,CAAciB,YAAd,CAAjB;AACAM,MAAAA,UAAU,CAACY,OAAX,CAAmBe,QAAnB,IAA+BD,KAA/B;AACAxB,MAAAA,UAAU,CAACU,OAAX,GAAqBc,KAArB;AACAtB,MAAAA,mBAAmB,CAACQ,OAApB,GAA8BF,IAAI,CAACC,GAAL,EAA9B;AACD,KALD;AAMA,WAAO,MAAM;AACXa,MAAAA,KAAK,CAACI,kBAAN;AACD,KAFD;AAGD,GAXD,EAWG,CAAClD,MAAD,EAASD,KAAT,EAAgBiB,YAAhB,EAA8Bc,qBAA9B,CAXH;AAaA;AACF;AACA;;;AACE,QAAMqB,iBAAiB,GAAGhC,eAAMiC,WAAN,CAAkB,MAAM;AAChD,UAAMC,WAAW,GAAGrD,MAAM,CAACD,KAAD,CAAN,CAAciB,YAAd,CAApB;AACA,UAAMsC,MAAM,GAAGhC,UAAU,CAACY,OAAX,CAAmBmB,WAAnB,CAAf;AAEA,UAAME,SAAS,GAAGC,kBAAkB,CAClCF,MADkC,EAElCnD,eAFkC,EAGlCO,WAHkC,EAIlCI,aAJkC,CAApC;AAOAO,IAAAA,UAAU,CAACa,OAAX,CAAmBuB,OAAnB,CAA4BC,IAAD,IAAU;AACnC,YAAMC,cAAc,GAAGD,IAAI,CAACE,GAAL,KAAaP,WAApC;AACA,UAAIM,cAAJ,EAAoB;AAEpB,YAAME,UAAU,GAAGvC,UAAU,CAACY,OAAX,CAAmBwB,IAAI,CAACE,GAAxB,CAAnB;;AACA,UAAIL,SAAS,KAAK,IAAlB,EAAwB;AACtB,kCAAY;AACVO,UAAAA,GAAG,EAAEJ,IAAI,CAACV,KADA;AAEVM,UAAAA,MAFU;AAGVS,UAAAA,QAAQ,EAAE;AAHA,SAAZ;AAKAzC,QAAAA,UAAU,CAACY,OAAX,CAAmBwB,IAAI,CAACE,GAAxB,IAA+BN,MAA/B;AACD,OAPD,MAOO,IAAIO,UAAU,GAAG1D,eAAb,IAAgC,CAAC0D,UAArC,EAAiD;AACtD,kCAAY;AACVC,UAAAA,GAAG,EAAEJ,IAAI,CAACV,KADA;AAEVM,UAAAA,MAAM,EAAEb,IAAI,CAACuB,GAAL,CAASV,MAAT,EAAiBnD,eAAjB,CAFE;AAGV4D,UAAAA,QAAQ,EAAE;AAHA,SAAZ;AAKD;AACF,KAnBD;AAoBD,GA/ByB,EA+BvB,CACDrD,WADC,EAEDP,eAFC,EAGDJ,KAHC,EAIDiB,YAJC,EAKDhB,MALC,EAMDc,aANC,CA/BuB,CAA1B;AAwCA;AACF;AACA;;;AACEK,iBAAM0B,eAAN,CAAsB,MAAM;AAC1B,QAAInC,WAAW,IAAI,CAACiB,OAApB,EAA6B;AAE7B,UAAM0B,WAAW,GAAGrD,MAAM,CAACD,KAAD,CAAN,CAAciB,YAAd,CAApB;AACA,UAAMsC,MAAM,GAAGhC,UAAU,CAACY,OAAX,CAAmBmB,WAAnB,CAAf;AAEAzB,IAAAA,UAAU,CAAC,KAAD,CAAV;AAEA,UAAM2B,SAAS,GAAGC,kBAAkB,CAClCF,MADkC,EAElCnD,eAFkC,EAGlCO,WAHkC,EAIlCI,aAJkC,CAApC;;AAOA,QAAIyC,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAKD,MAAxC,EAAgD;AAC9CjC,MAAAA,UAAU,CAACa,OAAX,CAAmBuB,OAAnB,CAA4BC,IAAD,IAAU;AACnC;AACA,kCAAY;AACVI,UAAAA,GAAG,EAAEJ,IAAI,CAACV,KADA;AAEVM,UAAAA,MAAM,EAAEC,SAFE;AAGVQ,UAAAA,QAAQ,EAAE;AAHA,SAAZ;AAKD,OAPD;AAQD;AACF,GAzBD,EAyBG,CACDpC,OADC,EAEDjB,WAFC,EAGDP,eAHC,EAIDJ,KAJC,EAKDiB,YALC,EAMDhB,MANC,EAODc,aAPC,CAzBH;;AAmCA,QAAMmD,SAAS,GAAG9C,eAAMiC,WAAN,CAAkB,MAAM;AACxC,UAAMC,WAAW,GAAGrD,MAAM,CAACD,KAAD,CAAN,CAAciB,YAAd,CAApB;AAEA,UAAMsC,MAAM,GAAGhC,UAAU,CAACY,OAAX,CAAmBmB,WAAnB,CAAf;AAEA,UAAME,SAAS,GAAGC,kBAAkB,CAClCF,MADkC,EAElCnD,eAFkC,EAGlCO,WAHkC,EAIlCI,aAJkC,CAApC,CALwC,CAYxC;;AACA,QAAIyC,SAAS,KAAK,IAAd,IAAsBD,MAAM,KAAKC,SAArC,EAAgD;AAC9C7B,MAAAA,mBAAmB,CAACQ,OAApB,GAA8BF,IAAI,CAACC,GAAL,EAA9B;AACAH,MAAAA,qBAAqB,CAACK,QAAtB;AACD;AACF,GAjBiB,EAiBf,CACDL,qBADC,EAEDpB,WAFC,EAGDP,eAHC,EAIDJ,KAJC,EAKDiB,YALC,EAMDhB,MANC,EAODc,aAPC,CAjBe,CAAlB;;AA2BA,QAAMoD,qBAAqB,GAAG,MAAM;AAClC3C,IAAAA,SAAS,CAACW,OAAV,GAAoB,IAApB;AACD,GAFD;;AAIA,QAAMiC,mBAAmB,GAAG,MAAM;AAChC5C,IAAAA,SAAS,CAACW,OAAV,GAAoB,KAApB;AACA+B,IAAAA,SAAS;AACTd,IAAAA,iBAAiB;AAClB,GAJD;;AAMA,QAAMiB,iBAAiB,GAAG,MAAM;AAC9B3C,IAAAA,iBAAiB,CAACS,OAAlB,GAA4B,IAA5B;AACAR,IAAAA,mBAAmB,CAACQ,OAApB,GAA8BF,IAAI,CAACC,GAAL,EAA9B;AACD,GAHD;;AAKA,QAAMoC,eAAe,GAAG,MAAM;AAC5B5C,IAAAA,iBAAiB,CAACS,OAAlB,GAA4B,KAA5B;AACAR,IAAAA,mBAAmB,CAACQ,OAApB,GAA8BF,IAAI,CAACC,GAAL,EAA9B,CAF4B,CAG5B;;AACAgC,IAAAA,SAAS;AACTd,IAAAA,iBAAiB;AAClB,GAND;;AAQA,QAAMmB,QAAQ,GAAG,MAAM;AACrB,UAAMjB,WAAW,GAAGrD,MAAM,CAACD,KAAD,CAAN,CAAciB,YAAd,CAApB;AACA,UAAMuD,UAAU,GAAGlD,UAAU,CAACa,OAAX,CAAmBsC,IAAnB,CAAyBC,CAAD,IAAOA,CAAC,CAACb,GAAF,KAAUP,WAAzC,CAAnB;;AACA,QAAIkB,UAAJ,EAAgB;AACd,YAAMjB,MAAM,GAAG5C,WAAW,GACtB+B,IAAI,CAACuB,GAAL,CAASxC,UAAU,CAACU,OAApB,EAA6B/B,eAA7B,CADsB,GAEtBqB,UAAU,CAACU,OAAX,IAAsB/B,eAAe,GAAGW,aAAxC,GACAX,eADA,GAEA,CAJJ;AAKA,gCAAY;AACV2D,QAAAA,GAAG,EAAES,UAAU,CAACvB,KADN;AAEVM,QAAAA,MAFU;AAGVS,QAAAA,QAAQ,EAAE;AAHA,OAAZ;AAKD;AACF,GAfD;AAiBA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,QAAMW,WAAW,GAAGvD,eAAMiC,WAAN,CACjBuB,QAAD,IAA+Bb,GAAD,IAAS;AACrC,QAAIA,GAAJ,EAAS;AACP,YAAMc,KAAK,GAAGvD,UAAU,CAACa,OAAX,CAAmBsC,IAAnB,CAAyBK,CAAD,IAAOA,CAAC,CAACjB,GAAF,KAAUe,QAAzC,CAAd;;AACA,UAAI,CAACC,KAAL,EAAY;AACVvD,QAAAA,UAAU,CAACa,OAAX,CAAmB4C,IAAnB,CAAwB;AACtBlB,UAAAA,GAAG,EAAEe,QADiB;AAEtB3B,UAAAA,KAAK,EAAEc;AAFe,SAAxB;AAID;AACF;AACF,GAXiB,EAYlB,EAZkB,CAApB;AAeA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,QAAMlD,YAAY,GAChBmE,KADmB,IAIC;AACpB,wBACE,6BAAC,iBAAD;AAAM,MAAA,KAAK,EAAE;AAAEC,QAAAA,MAAM,EAAE;AAAV;AAAb,OACG,CAAC,CAACrE,gBAAF,iBACC,6BAAC,qBAAD,CAAU,IAAV;AACE,MAAA,KAAK,EAAE;AACLsE,QAAAA,QAAQ,EAAE,UADL;AAELC,QAAAA,KAAK,EAAE,MAFF;AAGLC,QAAAA,MAAM,EAAE9E,YAAY,GAAGD,YAAf,GAA8BD,eAHjC;AAILiF,QAAAA,SAAS,EAAE,CAAC;AAAE9C,UAAAA;AAAF,SAAD;AAJN;AADT,OAQG3B,gBARH,CAFJ,EAcG,CAAC,CAACL,MAAF,iBACC,6BAAC,iBAAD;AAAM,MAAA,KAAK,EAAE;AAAE0E,QAAAA,MAAM,EAAE,IAAV;AAAgBG,QAAAA,MAAM,EAAE9E;AAAxB;AAAb,OAAsDC,MAAtD,CAfJ,eAiBE,6BAAC,qBAAD,CAAU,IAAV;AACE,MAAA,aAAa,EAAC,UADhB;AAEE,MAAA,KAAK,EAAE,CACL+E,MAAM,CAACC,eADF,EAEL;AACEC,QAAAA,GAAG,EAAElF,YADP;AAEE8E,QAAAA,MAAM,EAAEhF,eAAe,GAAGC,YAF5B;AAGEgF,QAAAA,SAAS,EAAE,CAAC;AAAE9C,UAAAA;AAAF,SAAD;AAHb,OAFK,EAOL9B,oBAPK;AAFT,OAYGP,YAAY,EAZf,EAaGY,kBAAkB,GACjB;AACAA,IAAAA,kBAAkB,CAAC,EACjB,GAAGkE,KADc;AAEjB,SAAGxE,WAFc;AAGjBgB,MAAAA,SAHiB;AAIjBd,MAAAA;AAJiB,KAAD,CAFD,gBASjB,6BAAC,0BAAD,eACMsE,KADN,EAEMxE,WAFN;AAGE,MAAA,UAAU,EAAGiF,KAAD,IAAW;AACrB,YAAIjE,SAAS,CAACW,OAAV,IAAqBzB,wBAAzB,EAAmD;AACjD+E,UAAAA,KAAK,CAACC,cAAN;AACD,SAHoB,CAIrB;;;AACA,SAAAlF,WAAW,SAAX,IAAAA,WAAW,WAAX,YAAAA,WAAW,CAAEmF,UAAb,KAA2BnF,WAAW,CAACmF,UAAZ,CAAuBF,KAAvB,CAA3B;AACD;AATH,OAtBJ,CAjBF,CADF;AAuDD,GA5DD;;AA8DA,QAAMG,YAAY,GAAGxE,eAAMiC,WAAN,CAAkB,MAAM;AAC3C1B,IAAAA,mBAAmB,CAACQ,OAApB,GAA8BF,IAAI,CAACC,GAAL,EAA9B;AACAR,IAAAA,iBAAiB,CAACS,OAAlB,GAA4B,IAA5B;AACD,GAHoB,EAGlB,EAHkB,CAArB;;AAKA,QAAM0D,UAAU,GAAGzE,eAAMiC,WAAN,CAAkB,MAAM;AACzC1B,IAAAA,mBAAmB,CAACQ,OAApB,GAA8BF,IAAI,CAACC,GAAL,EAA9B;AACAR,IAAAA,iBAAiB,CAACS,OAAlB,GAA4B,KAA5B;AACD,GAHkB,EAGhB,EAHgB,CAAnB;;AAKA,sBACE,6BAAC,iBAAD;AACE,IAAA,KAAK,EAAEmD,MAAM,CAACQ,SADhB;AAEE,IAAA,YAAY,EAAEF,YAFhB;AAGE,IAAA,aAAa,EAAEC,UAHjB;AAIE,IAAA,UAAU,EAAEA;AAJd,kBAME,6BAAC,qDAAD;AACE,IAAA,KAAK,EAAE;AACLE,MAAAA,cAAc,EAAE9F,MAAM,CAACD,KAAD,CAAN,CAAciB,YAAd,CADX;AAELE,MAAAA,OAAO,EAAEA,OAAO,CAACgB,OAFZ;AAGLwC,MAAAA,WAHK;AAILvE,MAAAA,eAJK;AAKLC,MAAAA,YALK;AAMLC,MAAAA,YANK;AAOL6D,MAAAA,qBAPK;AAQLE,MAAAA,iBARK;AASLC,MAAAA,eATK;AAULF,MAAAA,mBAVK;AAWLG,MAAAA,QAXK;AAYLpE,MAAAA,eAAe,EAAEA,eAAe,IAAI;AAZ/B;AADT,kBAgBE,6BAAC,2BAAD,eACMe,YADN;AAEE,IAAA,eAAe,EAAE;AAAElB,MAAAA,KAAF;AAASC,MAAAA;AAAT,KAFnB;AAGE,IAAA,YAAY,EAAEY;AAHhB,KAhBF,CANF,CADF;AA+BD,CAnWD;;AAqWA,MAAMyE,MAAM,GAAGU,wBAAWC,MAAX,CAAkB;AAC/BV,EAAAA,eAAe,EAAE;AACfC,IAAAA,GAAG,EAAE,CADU;AAEfP,IAAAA,MAAM,EAAE,CAFO;AAGfC,IAAAA,QAAQ,EAAE,UAHK;AAIfC,IAAAA,KAAK,EAAE;AAJQ,GADc;AAO/BW,EAAAA,SAAS,EAAE;AACTI,IAAAA,IAAI,EAAE,CADG;AAETC,IAAAA,QAAQ,EAAE;AAFD;AAPoB,CAAlB,CAAf;;eAaexG,kB;;;AAEf,SAAS8D,kBAAT,CACEF,MADF,EAEE6C,YAFF,EAGEzF,WAHF,EAIEI,aAJF,EAKE;AACA,SAAOwC,MAAM,IAAI,CAAV,IAAeA,MAAM,IAAI6C,YAAzB,GACHzF,WAAW,GACT4C,MADS,GAETA,MAAM,IAAI6C,YAAY,GAAGrF,aAAzB,GACA,CADA,GAEAwC,MAAM,GAAG6C,YAAY,GAAGrF,aAAxB,GACAqF,YADA,GAEA,IAPC,GAQH,IARJ;AASD","sourcesContent":["import React, { useRef } from 'react';\nimport { StyleSheet, Animated, ViewStyle, View } from 'react-native';\nimport {\n  TabView,\n  TabBar,\n  Route,\n  TabViewProps,\n  TabBarProps,\n  NavigationState,\n  SceneRendererProps,\n} from 'react-native-tab-view';\nimport { useDebouncedCallback } from 'use-debounce';\nimport { CollapsibleContextProvider } from './CollapsibleTabViewContext';\nimport scrollScene from './scrollScene';\nimport type { ScrollRef, GetRef } from './types';\n\ntype PTabBarProps<T extends Route> = Partial<TabBarProps<T>>;\n\nexport type RenderTabBarProps<T extends Route, P extends object = {}> = {\n  navigationState: NavigationState<T>;\n  isGliding: React.MutableRefObject<boolean>;\n  preventTabPressOnGliding: boolean;\n} & SceneRendererProps &\n  P;\n\nexport type Props<\n  T extends Route,\n  P extends object = PTabBarProps<T>\n> = Partial<Omit<TabViewProps<T>, 'renderTabBar'>> &\n  Pick<TabViewProps<T>, 'onIndexChange' | 'navigationState' | 'renderScene'> & {\n    /**\n     * Optionally controlled animated value.\n     * Default is `new Animated.Value(0)`.\n     */\n    animatedValue?: Animated.Value;\n    /**\n     * Container height\n     */\n    containerHeight?: number;\n    /**\n     * Collapsed header height, default is 0.\n     */\n    collapsedHeight: number;\n    /**\n     * Tab bar height, default is 48.\n     */\n    tabBarHeight?: number;\n    /**\n     * Props passed to the tab bar component.\n     */\n    tabBarProps?: P;\n    /**\n     * App bar component\n     */\n    appBar?: React.ReactNode | null;\n    /**\n     * App bar height\n     */\n    appBarHeight?: number;\n    /**\n     * Header rendered on top of the tab bar. Default is `() => null`\n     */\n    renderHeader?: () => React.ReactNode;\n    /**\n     * Styles applied to header and tabbar container.\n     */\n    headerContainerStyle?: Animated.WithAnimatedValue<ViewStyle>;\n    /**\n     * Prevent tab press if screen is gliding. Default is `true`\n     */\n    preventTabPressOnGliding?: boolean;\n    /**\n     * Disable the snap animation.\n     */\n    disableSnap?: boolean;\n    /**\n     * Same as `renderTab` of `TabViewProps`, but with the additional\n     * `isGliding` and `preventTabPressOnGliding` properties.\n     */\n    renderTabBar?: (props: RenderTabBarProps<T, P>) => React.ReactNode;\n    /**\n     * Custom header background element.\n     */\n    headerBackground?: React.ReactNode | null;\n    /**\n     * Callback fired when the `headerHeight` state value inside\n     * `CollapsibleTabView` will be updated in the `onLayout` event\n     * from the tab/header container. Useful to call layout animations\n     * Example:\n     *\n     * ```js\n     * const onHeaderHeightChange = () => {\n     *  LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut)\n     * }\n     * ```\n     */\n    onHeaderHeightChange?: () => void;\n    /**\n     * Percentage of header height to make the snap effect. A number between\n     * 0 and 1. Default is 0.5.\n     */\n    snapThreshold?: number;\n    /**\n     * How long to wait before initiating the snap effect, in milliseconds.\n     * Default is 100\n     */\n    snapTimeout?: number;\n    /**\n     * The property from the `routes` map to use for the active route key\n     * Default is 'key'\n     */\n    routeKeyProp?: keyof T;\n  };\n\n/**\n * `CollapsibleTabView` wraps the `TabView` and take care of animations /\n * scroll value computations. It should be used with `useCollapsibleScene`.\n */\nconst CollapsibleTabView = <\n  T extends Route,\n  P extends object = PTabBarProps<T>\n>({\n  animatedValue = new Animated.Value(0),\n  navigationState: { index, routes },\n  renderHeader = () => null,\n  containerHeight = 48,\n  collapsedHeight = 0,\n  tabBarHeight = 48,\n  appBarHeight = 0,\n  appBar,\n  tabBarProps,\n  headerContainerStyle,\n  preventTabPressOnGliding = true,\n  disableSnap = false,\n  headerBackground,\n  renderTabBar: customRenderTabBar,\n  snapThreshold = 0.5,\n  snapTimeout = 250,\n  routeKeyProp = 'key',\n  ...tabViewProps\n}: React.PropsWithoutRef<Props<T, P>>): React.ReactElement => {\n  const scrollY = React.useRef(animatedValue);\n  const listRefArr = React.useRef<{ key: T['key']; value?: ScrollRef }[]>([]);\n  const listOffset = React.useRef<{ [key: string]: number }>({});\n  const isGliding = React.useRef(false);\n  const prevOffset = React.useRef(0);\n  /** Used to keep track if the user is actively scrolling */\n  const isUserInteracting = React.useRef(false);\n  const lastInteractionTime = React.useRef(0);\n\n  const [canSnap, setCanSnap] = React.useState(false);\n\n  const activateSnapDebounced = useDebouncedCallback(\n    () => {\n      const lastInteractedAgo = Date.now() - lastInteractionTime.current;\n      // make sure the user is not currently still scrolling\n      if (!isUserInteracting.current && lastInteractedAgo > snapTimeout) {\n        setCanSnap(true);\n      } else {\n        // re-enter until we have no interactions in the past `snapTimeout`\n        activateSnapDebounced.callback();\n      }\n    },\n    16, // check about once per frame\n    { trailing: true, leading: false }\n  );\n\n  const translateY = useRef(\n    scrollY.current.interpolate({\n      inputRange: [0, Math.max(collapsedHeight, tabBarHeight)], // Always allow for a minimum of `tabBarHeight`\n      outputRange: [0, -collapsedHeight],\n      extrapolate: 'clamp',\n    })\n  ).current;\n\n  React.useLayoutEffect(() => {\n    const currY = scrollY.current;\n    currY.addListener(({ value }) => {\n      const curRoute = routes[index][routeKeyProp as keyof Route] as string;\n      listOffset.current[curRoute] = value;\n      prevOffset.current = value;\n      lastInteractionTime.current = Date.now();\n    });\n    return () => {\n      currY.removeAllListeners();\n    };\n  }, [routes, index, routeKeyProp, activateSnapDebounced]);\n\n  /**\n   * Sync the scroll of unfocused routes to the current focused route.\n   */\n  const syncScrollOffsets = React.useCallback(() => {\n    const curRouteKey = routes[index][routeKeyProp as keyof Route] as string;\n    const offset = listOffset.current[curRouteKey];\n\n    const newOffset = calculateNewOffset(\n      offset,\n      collapsedHeight,\n      disableSnap,\n      snapThreshold\n    );\n\n    listRefArr.current.forEach((item) => {\n      const isCurrentRoute = item.key === curRouteKey;\n      if (isCurrentRoute) return;\n\n      const itemOffset = listOffset.current[item.key];\n      if (newOffset !== null) {\n        scrollScene({\n          ref: item.value,\n          offset,\n          animated: false,\n        });\n        listOffset.current[item.key] = offset;\n      } else if (itemOffset < collapsedHeight || !itemOffset) {\n        scrollScene({\n          ref: item.value,\n          offset: Math.min(offset, collapsedHeight),\n          animated: false,\n        });\n      }\n    });\n  }, [\n    disableSnap,\n    collapsedHeight,\n    index,\n    routeKeyProp,\n    routes,\n    snapThreshold,\n  ]);\n\n  /**\n   * Snapping\n   */\n  React.useLayoutEffect(() => {\n    if (disableSnap || !canSnap) return;\n\n    const curRouteKey = routes[index][routeKeyProp as keyof Route] as string;\n    const offset = listOffset.current[curRouteKey];\n\n    setCanSnap(false);\n\n    const newOffset = calculateNewOffset(\n      offset,\n      collapsedHeight,\n      disableSnap,\n      snapThreshold\n    );\n\n    if (newOffset !== null && newOffset !== offset) {\n      listRefArr.current.forEach((item) => {\n        // scroll everything because we could be moving to a new tab\n        scrollScene({\n          ref: item.value,\n          offset: newOffset,\n          animated: true,\n        });\n      });\n    }\n  }, [\n    canSnap,\n    disableSnap,\n    collapsedHeight,\n    index,\n    routeKeyProp,\n    routes,\n    snapThreshold,\n  ]);\n\n  const maybeSnap = React.useCallback(() => {\n    const curRouteKey = routes[index][routeKeyProp as keyof Route] as string;\n\n    const offset = listOffset.current[curRouteKey];\n\n    const newOffset = calculateNewOffset(\n      offset,\n      collapsedHeight,\n      disableSnap,\n      snapThreshold\n    );\n\n    // only snap if the current offset is different\n    if (newOffset !== null && offset !== newOffset) {\n      lastInteractionTime.current = Date.now();\n      activateSnapDebounced.callback();\n    }\n  }, [\n    activateSnapDebounced,\n    disableSnap,\n    collapsedHeight,\n    index,\n    routeKeyProp,\n    routes,\n    snapThreshold,\n  ]);\n\n  const onMomentumScrollBegin = () => {\n    isGliding.current = true;\n  };\n\n  const onMomentumScrollEnd = () => {\n    isGliding.current = false;\n    maybeSnap();\n    syncScrollOffsets();\n  };\n\n  const onScrollBeginDrag = () => {\n    isUserInteracting.current = true;\n    lastInteractionTime.current = Date.now();\n  };\n\n  const onScrollEndDrag = () => {\n    isUserInteracting.current = false;\n    lastInteractionTime.current = Date.now();\n    // make sure we snap if the user keeps his finger in the same position for a while then lifts it\n    maybeSnap();\n    syncScrollOffsets();\n  };\n\n  const onLayout = () => {\n    const curRouteKey = routes[index][routeKeyProp];\n    const currentRef = listRefArr.current.find((r) => r.key === curRouteKey);\n    if (currentRef) {\n      const offset = disableSnap\n        ? Math.min(prevOffset.current, collapsedHeight)\n        : prevOffset.current >= collapsedHeight * snapThreshold\n        ? collapsedHeight\n        : 0;\n      scrollScene({\n        ref: currentRef.value,\n        offset,\n        animated: false,\n      });\n    }\n  };\n\n  /**\n   * Function to be passed as ref for the scrollable animated\n   * component inside the tab scene.\n   *\n   * One of: Animated.[SrcollView | FlatList]\n   *\n   * It is exposed in the context.\n   */\n  const buildGetRef = React.useCallback(\n    (routeKey: string): GetRef => (ref) => {\n      if (ref) {\n        const found = listRefArr.current.find((e) => e.key === routeKey);\n        if (!found) {\n          listRefArr.current.push({\n            key: routeKey,\n            value: ref,\n          });\n        }\n      }\n    },\n    []\n  );\n\n  /**\n   *\n   * Wraps the tab bar with `Animated.View` to\n   * control the translateY property.\n   *\n   * Render the header with `renderHeader` prop.\n   *\n   * Render the default `<TabBar />` with additional\n   * `tabBarProps`, or a custom tab bar from the\n   * `renderTabBar` prop, inside the Animated wrapper.\n   */\n  const renderTabBar = (\n    props: SceneRendererProps & {\n      navigationState: NavigationState<T>;\n    }\n  ): React.ReactNode => {\n    return (\n      <View style={{ zIndex: 1000 }}>\n        {!!headerBackground && (\n          <Animated.View\n            style={{\n              position: 'absolute',\n              width: '100%',\n              height: appBarHeight + tabBarHeight + collapsedHeight,\n              transform: [{ translateY }],\n            }}\n          >\n            {headerBackground}\n          </Animated.View>\n        )}\n\n        {!!appBar && (\n          <View style={{ zIndex: 1000, height: appBarHeight }}>{appBar}</View>\n        )}\n        <Animated.View\n          pointerEvents=\"box-none\"\n          style={[\n            styles.headerContainer,\n            {\n              top: appBarHeight,\n              height: collapsedHeight + tabBarHeight,\n              transform: [{ translateY }],\n            },\n            headerContainerStyle,\n          ]}\n        >\n          {renderHeader()}\n          {customRenderTabBar ? (\n            // @ts-ignore\n            customRenderTabBar({\n              ...props,\n              ...tabBarProps,\n              isGliding,\n              preventTabPressOnGliding,\n            })\n          ) : (\n            <TabBar\n              {...props}\n              {...tabBarProps}\n              onTabPress={(event) => {\n                if (isGliding.current && preventTabPressOnGliding) {\n                  event.preventDefault();\n                }\n                // @ts-ignore\n                tabBarProps?.onTabPress && tabBarProps.onTabPress(event);\n              }}\n            />\n          )}\n        </Animated.View>\n      </View>\n    );\n  };\n\n  const onTouchStart = React.useCallback(() => {\n    lastInteractionTime.current = Date.now();\n    isUserInteracting.current = true;\n  }, []);\n\n  const onTouchEnd = React.useCallback(() => {\n    lastInteractionTime.current = Date.now();\n    isUserInteracting.current = false;\n  }, []);\n\n  return (\n    <View\n      style={styles.container}\n      onTouchStart={onTouchStart}\n      onTouchCancel={onTouchEnd}\n      onTouchEnd={onTouchEnd}\n    >\n      <CollapsibleContextProvider\n        value={{\n          activeRouteKey: routes[index][routeKeyProp as keyof Route] as string,\n          scrollY: scrollY.current,\n          buildGetRef,\n          collapsedHeight,\n          tabBarHeight,\n          appBarHeight,\n          onMomentumScrollBegin,\n          onScrollBeginDrag,\n          onScrollEndDrag,\n          onMomentumScrollEnd,\n          onLayout,\n          containerHeight: containerHeight || 0,\n        }}\n      >\n        <TabView\n          {...tabViewProps}\n          navigationState={{ index, routes }}\n          renderTabBar={renderTabBar}\n        />\n      </CollapsibleContextProvider>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  headerContainer: {\n    top: 0,\n    zIndex: 1,\n    position: 'absolute',\n    width: '100%',\n  },\n  container: {\n    flex: 1,\n    overflow: 'hidden',\n  },\n});\n\nexport default CollapsibleTabView;\n\nfunction calculateNewOffset(\n  offset: number,\n  headerHeight: number,\n  disableSnap: boolean,\n  snapThreshold: number\n) {\n  return offset >= 0 && offset <= headerHeight\n    ? disableSnap\n      ? offset\n      : offset <= headerHeight * snapThreshold\n      ? 0\n      : offset > headerHeight * snapThreshold\n      ? headerHeight\n      : null\n    : null;\n}\n"]}